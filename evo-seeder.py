#!/usr/bin/env python3
import json
import os
import sys
import uuid
from pathlib import Path
from textwrap import dedent

SSL_METHOD = "ssl-on-alternate-port"  # Evolution's value for "SSL" (implicit TLS)

def resolve_sources_dir():
    # Prefer Flatpak Evolution config if present; otherwise XDG config
    flatpak_dir = Path.home() / ".var/app/org.gnome.Evolution/config/evolution/sources"
    if flatpak_dir.exists():
        flatpak_dir.mkdir(parents=True, exist_ok=True)
        return flatpak_dir
    xdg = os.environ.get("XDG_CONFIG_HOME", str(Path.home() / ".config"))
    sources_dir = Path(xdg) / "evolution/sources"
    sources_dir.mkdir(parents=True, exist_ok=True)
    return sources_dir

def write(path: Path, content: str):
    path.write_text(content, encoding="utf-8")
    print(f"Wrote {path}")

def force_ssl(cfg: dict) -> dict:
    """Ensure both IMAP & SMTP use SSL regardless of input."""
    cfg = dict(cfg)  # shallow copy
    imap = dict(cfg.get("imap", {}))
    smtp = dict(cfg.get("smtp", {}))
    imap["security"] = SSL_METHOD
    smtp["security"] = SSL_METHOD
    cfg["imap"] = imap
    cfg["smtp"] = smtp
    return cfg

def build_account_source(uid_acc, uid_id, display_name, imap, check_interval):
    return dedent(f"""
    [Data Source]
    DisplayName={display_name}
    Enabled=true
    Parent=

    [Mail Account]
    IdentityUid={uid_id}
    BackendName=imapx

    [Authentication]
    Host={imap['host']}
    Port={imap.get('port', 993)}
    User={imap.get('username', '')}
    Method={imap.get('auth_method', 'none')}
    ProxyUid=system-proxy
    

    [Message Disposition Notifications]
    ResponsePolicy=never

    [Offline]
    StaySynchronized=false

    [Refresh]
    Enabled=false
    IntervalMinutes={int(check_interval)}

    [Security]
    Method={imap.get('security', SSL_METHOD)}

    [Imapx Backend]
    CheckAll=true
    BatchFetchCount=500
    UseIdle=true
    UseQresync=true
    UseSubscriptions=true
    """).strip() + "\n"

def build_identity_source(uid_id, uid_acc, uid_tx, real_name, email):
    return dedent(f"""
    [Data Source]
    DisplayName={email}
    Enabled=true
    Parent={uid_acc}

    [Mail Identity]
    Name={real_name}
    Address={email}
    ReplyTo=
    Organization=
    SignatureUid=autogenerated

    [Mail Composition]
    DraftsFolder=folder://{uid_acc}/Drafts
    SignImip=true

    [Mail Submission]
    TransportUid={uid_tx}
    SentFolder=folder://{uid_acc}/Sent
    """).strip() + "\n"

def build_transport_source(uid_tx, uid_acc, smtp, display_name):
    return dedent(f"""
    [Data Source]
    DisplayName={display_name}
    Enabled=true
    Parent={uid_acc}

    [Mail Transport]
    BackendName=smtp

    [Authentication]
    Host={smtp['host']}
    Method={smtp.get('auth_method', 'PLAIN')}
    Port={smtp.get('port', 465)}
    User={smtp.get('username', '')}
    ProxyUid=system-proxy

    [Security]
    Method={smtp.get('security', SSL_METHOD)}
    """).strip() + "\n"

def add_account(sources_dir: Path, cfg: dict):
    cfg = force_ssl(cfg)  # enforce SSL
    display_name = cfg.get("display_name", cfg.get("email", "Mail Account"))
    real_name = cfg.get("real_name", cfg.get("email", ""))
    email = cfg["email"]
    imap = cfg["imap"]
    smtp = cfg["smtp"]
    check_interval = cfg.get("check_interval_minutes", 10)

    # Generate UIDs
    uid_acc = f"acc-{uuid.uuid4().hex[:8]}"
    uid_id  = f"id-{uuid.uuid4().hex[:8]}"
    uid_tx  = f"tx-{uuid.uuid4().hex[:8]}"

    # Paths
    acc_path = sources_dir / f"{uid_acc}.source"
    id_path  = sources_dir / f"{uid_id}.source"
    tx_path  = sources_dir / f"{uid_tx}.source"

    # Contents
    acc_content = build_account_source(uid_acc, uid_id, display_name, imap, check_interval)
    id_content  = build_identity_source(uid_id, uid_acc, uid_tx, real_name, email)
    tx_content  = build_transport_source(uid_tx, uid_acc, smtp, display_name)

    # Write
    write(acc_path, acc_content)
    write(id_path, id_content)
    write(tx_path, tx_content)

def main():
    if len(sys.argv) != 2:
        print("Usage: evo_add_accounts.py <accounts.json>", file=sys.stderr)
        sys.exit(1)

    cfg_path = Path(sys.argv[1])
    data = json.loads(cfg_path.read_text(encoding="utf-8"))

    sources_dir = resolve_sources_dir()

    # Accept a single object or a list
    accounts = data if isinstance(data, list) else [data]

    for idx, cfg in enumerate(accounts, 1):
        print(f"\n=== Adding account {idx} of {len(accounts)}: {cfg.get('email','(no email)')} ===")
        required = ("email", "imap", "smtp")
        missing = [k for k in required if k not in cfg]
        if missing:
            print(f"  Skipped: missing required fields: {', '.join(missing)}", file=sys.stderr)
            continue
        add_account(sources_dir, cfg)

    print("\nAll done.")
    print("If Evolution is running, restart it:")
    print("  evolution --force-shutdown && evolution")
    print("\nNote: Passwords are stored via GNOME Keyring;")
    print("you may be prompted on first connect.")

if __name__ == "__main__":
    main()
