#!/usr/bin/env python3
import json
import os
import sys
import uuid
from pathlib import Path
from textwrap import dedent

def resolve_sources_dir():
    # Prefer Flatpak Evolution config if present; otherwise XDG config
    # Flatpak path (host): ~/.var/app/org.gnome.Evolution/config/evolution/sources
    flatpak_dir = Path.home() / ".var/app/org.gnome.Evolution/config/evolution/sources"
    if flatpak_dir.exists():
        flatpak_dir.mkdir(parents=True, exist_ok=True)
        return flatpak_dir

    xdg = os.environ.get("XDG_CONFIG_HOME", str(Path.home() / ".config"))
    sources_dir = Path(xdg) / "evolution/sources"
    sources_dir.mkdir(parents=True, exist_ok=True)
    return sources_dir

def write(path: Path, content: str):
    path.write_text(content, encoding="utf-8")
    print(f"Wrote {path}")

def build_account_source(uid_acc, uid_id, display_name, imap, check_interval):
    # [Mail Account] file (incoming / IMAP)
    return dedent(f"""
    [Data Source]
    DisplayName={display_name}
    Enabled=true
    Parent=

    [Mail Account]
    IdentityUid={uid_id}
    BackendName=imapx

    [Authentication]
    Host={imap['host']}
    Port={imap['port']}
    User={imap.get('username', '')}
    Method={imap.get('auth_method','none')}
    ProxyUid=system-proxy

    [Message Disposition Notifications]
    ResponsePolicy=never

    [Offline]
    StaySynchronized=false

    [Refresh]
    Enabled=false
    IntervalMinutes={int(check_interval)}

    [Security]
    Method={imap.get('security','ssl-on-alternate-port')}

    [Imapx Backend]
    CheckAll=true
    BatchFetchCount=500
    UseIdle=true
    UseQresync=true
    UseSubscriptions=true
    """).strip() + "\n"

def build_identity_source(uid_id, uid_acc, uid_tx, real_name, email):
    return dedent(f"""
    [Data Source]
    DisplayName={email}
    Enabled=true
    Parent={uid_acc}

    [Mail Identity]
    Name={real_name}
    Address={email}
    ReplyTo=
    Organization=
    SignatureUid=autogenerated

    [Mail Composition]
    DraftsFolder=folder://{uid_acc}/Drafts
    SignImip=true

    [Mail Submission]
    TransportUid={uid_tx}
    SentFolder=folder://{uid_acc}/Sent
    """).strip() + "\n"

def build_transport_source(uid_tx, uid_acc, smtp, display_name):
    return dedent(f"""
    [Data Source]
    DisplayName={display_name}
    Enabled=true
    Parent={uid_acc}

    [Mail Transport]
    BackendName=smtp

    [Authentication]
    Host={smtp['host']}
    Method={smtp.get('auth_method','PLAIN')}
    Port={smtp['port']}
    User={smtp.get('username','')}
    ProxyUid=system-proxy

    [Security]
    Method={smtp.get('security','ssl-on-alternate-port')}
    """).strip() + "\n"

def main():
    if len(sys.argv) != 2:
        print("Usage: evo_add_account.py <account.json>", file=sys.stderr)
        sys.exit(1)

    cfg_path = Path(sys.argv[1])
    data = json.loads(cfg_path.read_text(encoding="utf-8"))

    display_name = data.get("display_name", data.get("email", "Mail Account"))
    real_name = data.get("real_name", data.get("email", ""))
    email = data["email"]
    imap = data["imap"]
    smtp = data["smtp"]
    check_interval = data.get("check_interval_minutes", 10)

    sources_dir = resolve_sources_dir()

    # Generate UIDs (file basenames without .source)
    uid_acc = f"acc-{uuid.uuid4().hex[:8]}"
    uid_id  = f"id-{uuid.uuid4().hex[:8]}"
    uid_tx  = f"tx-{uuid.uuid4().hex[:8]}"

    # Prepare file paths
    acc_path = sources_dir / f"{uid_acc}.source"
    id_path  = sources_dir / f"{uid_id}.source"
    tx_path  = sources_dir / f"{uid_tx}.source"

    # Build contents
    acc_content = build_account_source(uid_acc, uid_id, display_name, imap, check_interval)
    id_content  = build_identity_source(uid_id, uid_acc, uid_tx, real_name, email)
    tx_content  = build_transport_source(uid_tx, uid_acc, smtp, display_name)

    # Write files
    write(acc_path, acc_content)
    write(id_path, id_content)
    write(tx_path, tx_content)

    print("\nDone. If Evolution is running, restart it with:")
    print("  evolution --force-shutdown && evolution")
    print("\nNote: Passwords are stored via GNOME Keyring;")
    print("you may be prompted for them on first connect.")

if __name__ == "__main__":
    main()
